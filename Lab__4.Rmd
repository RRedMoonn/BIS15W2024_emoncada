---
title: "Lab 4"
output: html_document
date: "2024-02-06"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Build a vector that includes the following height measurements for five plants:
plant 1 30.7, plant 2 37.6, plant 3 28.4, plant 4 NA, plant 5 33.2

Creating a Plant Height Vector.
```{r}
plant_height <- c(30.7, 37.6, 28.4, NA, 33.2)
```
Build another vector that includes the following mass measurements:
plant 1 4, plant 2 5.2, plant 3 3.7, plant 4 NA, plant 5 4.6

Creating a Plant Weight Vector.
```{r}
plant_weight <- c(4, 5.2, 3.7, NA, 4.6)
```
Assemble these vectors into a labeled data matrix with two columns

Labels for data matrix.
```{r}
samples <- c("plant1", "plant2", "plant3", "plant4", "plant5")
measured <- c("height", "weight")
```

Combine data for height and weight.
```{r}
plant_experiment <- c(plant_height, plant_weight)
```

Build the data matrix.
```{r}
plant_experiment_matrix <- matrix(plant_experiment, nrow = 5, byrow = F)
```

Name the columns and rows.
```{r}
colnames(plant_experiment_matrix) <- measured
rownames(plant_experiment_matrix) <- samples
```

Calculate the mean for height and mass and add them to the data matrix

Calculate the means of each column.
```{r}
plant_means <- colMeans(plant_experiment_matrix, na.rm=T)
```

Add this as a new row.
```{r}
plant_experiment_matrix_final <- rbind(plant_experiment_matrix, plant_means)
```

Print the matrix.
```{r}
plant_experiment_matrix_final
```

## Types of Data
There are five frequently used `classes` of data: 1. numeric, 2. integer, 3. character, 4. logical, 5. complex.
```{r}
my_numeric <- 42
my_integer <- 2L #adding an L automatically denotes an integer
my_character <- "universe"
my_logical <- FALSE
my_complex <- 2+4i
```

To find out what type of data you are working with, use the `class()` function. This is important because sometimes we will need to change the type of data to perform certain analyses.
```{r}
class(my_numeric)
```

You can use the `is()` and `as()` functions to clarify or specify a type of data.
```{r}
is.integer(my_numeric) #is my_numeric an integer?
```

```{r}
my_integer <- 
  as.integer(my_numeric) #create a new object specified as an integer
```

```{r}
is.integer(my_integer) #is my_numeric an integer?
```

## Missing Data
R has a special way to designate missing data, the NA. NA values in R have specific properties which are very useful if your data contains any missing values. Later this quarter we will have a session focused on dealing with NAs.  

NA values are used to designate missing data. `is.na` or `anyNA` are useful functions when dealing with NAs in data. 
```{r}
my_missing <- NA
```

```{r}
is.na(my_missing)
```

```{r}
anyNA(my_missing)
```

## Practice  
1. Let's create a vector that includes some missing data (we will discuss vectors more in part 2). For now, run the following code chunk.  
```{r}
new_vector <- c(7, 6.2, 5, 9, NA, 4, 9.8, 7, 3, 2)
```

2. As we did in homework 1, calculate the mean of `new_vector`.
```{r}

```

3. How do you interpret this result? What does this mean about NAs?  

4. Recalculate the mean using the following code chunk. Why is the useful?  
```{r}
mean(new_vector, na.rm=T) #na.rm removes the NA values in the vector
```

Lab_2


## Data Structures
In addition to classes of data, R also organizes data in different ways. These are called data structures and include vectors, lists, matrices, data frames, and factors. For now, we will focus on `vectors`.  

## Vectors
Vectors are a common way of organizing data in R.  We create vectors using the `c` command. The `c` stands for concatenate.  

A numeric vector.
```{r}
my_vector <- c(10, 20, 30)
```

A character vector. Characters always have quotes and may be referred to as "strings".
```{r}
days_of_the_week <- c("Monday", "Tuesday", "Wednesday", "Thrusday", "Friday", "Saturday", "Sunday")
```

A convenient trick for creating a vector is to generate a sequence of numbers.
```{r}
my_vector_sequence <- c(1:100)
my_vector_sequence
```

## Identifying vector elements
We can use `[]` to pull out elements in a vector. We just need to specify their position in the vector; i.e. day 3 is Wednesday.
```{r}
days_of_the_week[3]
```

## Practice
Work through these examples and make adjustments to the values to experiment.

1. Evaluate all numerics in `my_vector_sequence` to determine which has a value of 15.  


2. We can use operators such as <, >, ==, <==, etc. Show all values in `my_vector_sequence` that are less than 10.  How about less than or equal to 10?  


3. If you use `[]` then you only get the values, not the logical evaluation of the entire vector. Experiment with this by adjusting the chunk below.    


## Data Matrices
Data matrices are a series of stacked vectors, similar to a data table. In the example below, we build a new data matrix using the matrix command.  

Box office earnings for Harry Potter movies (in millions!). Notice that these are separate vectors.  
```{r}
Philosophers_Stone <- c(317.5, 657.1)
Chamber_of_Secrets <- c(261.9, 616.9)
Prisoner_of_Azkaban <- c(249.5, 547.1)
Goblet_of_Fire <- c(290.0, 606.8)
Order_of_the_Phoenix <- c(292.0, 647.8)
Half_Blood_Prince <- c(301.9, 632.4)
Deathly_Hallows_1 <- c(295.9, 664.3)
Deathly_Hallows_2 <- c(381.0, 960.5)
```

Create a new object called `box_office`. Here we are using the `c` command to combine the vectors into one.
```{r}
box_office <- c(Philosophers_Stone, Chamber_of_Secrets, Prisoner_of_Azkaban, Goblet_of_Fire, Order_of_the_Phoenix, Half_Blood_Prince, Deathly_Hallows_1, Deathly_Hallows_2)
box_office
```

Create `harry_potter_matrix` using the `matrix()` command. We need to tell R how to organize the `box_office` vector using the `nrow` and `byrow` commands.
```{r}
harry_potter_matrix <- matrix(box_office, nrow = 8, byrow = T)
harry_potter_matrix
```
## Name the rows and columns
Vectors `region` and `titles`, used for naming.
```{r}
region <- c("US", "non-US")
region
```

```{r}
titles <- c("Philosophers_Stone", "Chamber_of_Secrets", "Prisoner_of_Azkaban", "Goblet_of_Fire", "Order_of_the_Phoenix", "Half_Blood_Prince", "Deathly_Hallows_1", "Deathly_Hallows_2")
titles
```

Name the columns using `colnames()` with the vector region.
```{r}
colnames(harry_potter_matrix) <- region
```

Name the rows using `rownames()` with the vector titles.
```{r}
rownames(harry_potter_matrix) <- titles
```

Print `harry_potter_matrix`.
```{r}
harry_potter_matrix
```

## Using a data matrix
Once you have a data matrix, you can perform lots of different analyses. For example, you can calculate the total earnings of each movie.
```{r}
global <- rowSums(harry_potter_matrix)
global
```

And even add a new column to reflect this calculation. `cbind()` adds columns.
```{r}
all_harry_potter_matrix <- cbind(harry_potter_matrix, global)
all_harry_potter_matrix
```

## Practice
1. What are the total earnings for the US and non-US regions?  


2. Add this information to the data matrix. Hint: you are adding a row, not a column.  


## A few Extras
The same methods of selecting elements in a vector apply to data matrices. We use `[]`. The following selects the value in the first column, second row.
```{r}
harry_potter_matrix[2,1]
```

Adding a colon `:` selects the specified elements in a column.  
```{r}
harry_potter_matrix[1:4]
```

We can also select values in an entire row or column. This can be useful for calculations. Here we calculate the mean of the entire second column. 
```{r}
non_us_earnings <- all_harry_potter_matrix[ ,2]
mean(non_us_earnings)
```

Lab3_1


## Data Frames
During lab 2, you learned how to work with vectors and data matrices. Today we will organize the vectors into a new type of data structure called a **data frame**. The data frame is the most common way to organize data within R. You can think of a data frame as similar to a spreadsheet. A data frame can store data of many different classes.  

Let's build separate vectors that include length (in), weight (oz), and sex of three [ruby-throated hummingbirds](https://www.audubon.org/field-guide/bird/ruby-throated-hummingbird).  
```{r}
Sex <- c("male", "female", "male")
Length <- c(3.2, 3.7, 3.4)
Weight <- c(2.9, 4.0, 3.1)
```

Here we combine our three vectors to create a data frame with the function `data.frame()`.
```{r}
hbirds <- data.frame(Sex, Length, Weight)
hbirds
```

OK, stop and think- how does this differ from making a data matrix? Are the data treated differently?  
```{r}
hummingbirds <- c(Sex, Length, Weight)
hummingbirds_matrix <- matrix(hummingbirds, ncol=3, byrow = F)
hummingbirds_matrix
```

Notice that not only are the data neat and clean looking, there is also information provided about the class of data. `dbl` means that the value is a type of numeric [double precision floating point](http://uc-r.github.io/integer_double/). 



## Accessing Data Frame Columns and Rows 
The same methods of selecting elements in vectors and data matrices apply to data frames. We use `[]`. We have two positions where the first applies to the rows, and the second to the columns.  

The first row.  
```{r}
hbirds[1,]
```

The third column.  
```{r}
hbirds[ ,3]
```

We can also select values in an entire column using the `$` sign. This can be useful for calculations. Here we calculate the mean of all of the birds weights. 
```{r}

```

## Adding Rows
We can add a new bird's data with the `rbind()` function, known as row bind. It will bind our new vector to our data frame row-wise.
```{r}
new_bird <- c("female", 3.6, 3.9)
new_bird
```

```{r}
hbirds<- rbind(hbirds, new_bird)
hbirds
```

## Adding Columns
What if we come across more data and we want to add it to our data frame? We can also do that with the `$` operator.
```{r}
hbirds$neighborhood <- c("lakewood", "brentwood", "lakewood", "scenic Heights")
hbirds
```

## Writing Data to File
We should save our hbirds data frame so we can use it again later! There are many ways to save data in R, here we write our data frame to a csv file. We use `row.names = FALSE` to avoid row numbers from printing out. 
```{r}
write.csv(hbirds, "hbirds_data.csv", row.names = FALSE)
```

## Load the data
Here we open a .csv file. Since we are using the tidyverse, we open the file using `read_csv()`. `readr` is included in the tidyverse set of packages. We specify the package and function with the `::` symbol. This becomes important if you have multiple packages loaded that contain functions with the same name.  

In the previous part of the lab, you exported a `.csv` of hot springs data. Let's try to reload that `.csv`.  
```{r}

```

Use the `str()` function to get an idea of the data structure of `hot_springs`.  
```{r}

```

What is the class of the scientist column? Change it to factor and then show the levels of that factor.  
```{r}

```

```{r}

```

```{r}

```

## Practice
1. In your lab 3 folder there is another folder titled `data`. Inside the `data` folder there is a `.csv` titled `Gaeta_etal_CLC_data.csv`. Open this data and store them as an object called `fish`.  

The data are from: Gaeta J., G. Sass, S. Carpenter. 2012. Biocomplexity at North Temperate Lakes LTER: Coordinated Field Studies: Large Mouth Bass Growth 2006. Environmental Data Initiative.  [link](https://portal.edirepository.org/nis/mapbrowse?scope=knb-lter-ntl&identifier=267)  
```{r}

```

2. What is the structure of these data?
```{r}

```

```{r}

```

Notice that when the data are imported, you are presented with a message that tells you how R interpreted the column classes. This is also where error messages will appear if there are problems.  

## Summary functions
Once data have been uploaded, you may want to get an idea of its structure, contents, and dimensions. I routinely run one or more of these commands when data are first imported.  

We can summarize our data frame with the`summary()` function.  
```{r}

```

`glimpse()` is another useful summary function.
```{r}

```

`nrow()` gives the numbers of rows.
```{r}

```

`ncol` gives the number of columns.
```{r}

```

`dim()` gives the dimensions.
```{r}

```

`names` gives the column names.
```{r}

```

`head()` prints the first n rows of the data frame.
```{r}

```

`tail()` prinst the last n rows of the data frame.
```{r}

```

`table()` is useful when you have a limited number of categorical variables. It produces fast counts of the number of observations in a variable. We will come back to this later... 
```{r}

```

We can also click on the `fish` data frame in the Environment tab or type View(fish).
```{r}
#View(fish)
```

## Filter
Filter is a way of pulling out observations that meet specific criteria in a variable. We will work a lot more with this in the next lab.  
```{r}

```

## Practice
1. Load the data `mammal_lifehistories_v2.csv` and place it into a new object called `mammals`.
```{r}

```

2. Provide the dimensions of the data frame.
```{r}

```

3. Check the column names in the data frame. 
```{r}

```

4. Use `str()` to show the structure of the data frame and its individual columns; compare this to `glimpse()`. 
```{r}

```

```{r}

```

5. . Try the `table()` command to produce counts of mammal order, family, and genus.  
```{r}

```


## Load the data
These data are from: Gaeta J., G. Sass, S. Carpenter. 2012. Biocomplexity at North Temperate Lakes LTER: Coordinated Field Studies: Large Mouth Bass Growth 2006. Environmental Data Initiative.  [link](https://portal.edirepository.org/nis/mapbrowse?scope=knb-lter-ntl&identifier=267)  
```{r}
fish <- readr::read_csv("data/Gaeta_etal_CLC_data.csv")
```

Lab4_1


## dplyr
The first package that we will use that is part of the tidyverse is `dplyr`. `dplyr` is used to transform data frames by extracting, rearranging, and summarizing data such that they are focused on a question of interest. This is very helpful,  especially when wrangling large data, and makes dplyr one of most frequently used packages in the tidyverse. The two functions we will use most are `select()` and `filter()`.  

## `select()`
Select allows you to pull out columns of interest from a dataframe. To do this, just add the names of the columns to the `select()` command. The order in which you add them, will determine the order in which they appear in the output.
```{r}
names(fish)
```

We are only interested in lakeid and scalelength.
```{r}
select(fish, "lakeid", "scalelength")
```

To add a range of columns use `start_col:end_col`.
```{r}
select(fish, fish_id:length)
```

The - operator is useful in select. It allows us to select everything except the specified variables.
```{r}
select(fish, -fish_id, -annnumber, -length, -radii_length_mm)
```

For very large data frames with lots of variables, `select()` utilizes lots of different operators to make things easier. Let's say we are only interested in the variables that deal with length.

```{r}
names(fish)
```

```{r}
select(fish, contains("length"))
```

When columns are sequentially named, `starts_with()` makes selecting columns easier.
```{r}
select(fish, starts_with("radii"))
```

Options to select columns based on a specific criteria include:  
1. ends_with() = Select columns that end with a character string  
2. contains() = Select columns that contain a character string  
3. matches() = Select columns that match a regular expression  
4. one_of() = Select columns names that are from a group of names  

```{r}
names(fish)
```

```{r}
select(fish, ends_with("id"))
```

```{r}
select(fish, contains("fish"))
```

We won't cover regular expressions [regex](https://en.wikipedia.org/wiki/Regular_expression) in this class, but the following code is helpful when you know that a column contains a letter (in this case "a") followed by a subsequent string (in this case "er").  
```{r}
select(fish, matches("a.+er"))
```

You can also select columns based on the class of data.  
```{r}
glimpse(fish)
```

```{r}
select_if(fish, is.numeric)
```

To select all columns that are *not* a class of data, you need to add a `~`.
```{r}
select_if(fish, ~!is.numeric(.))
```

Lab4_2


## Load the data
For these exercises we will use the data from lab 4_1.  
```{r}
fish <- read_csv("data/Gaeta_etal_CLC_data.csv")
```

```{r}
mammals <- read_csv("data/mammal_lifehistories_v2.csv")
```

To keep things tidy, I am going to rename the variables in the mammals data.  
```{r}
mammals <- rename(mammals, genus=Genus, wean_mass="wean mass", max_life="max. life", litter_size="litter size", litters_per_year="litters/year")
```

## `filter()`
Unlike `select()`, `filter()` allows us to extract data that meet specific criteria within a variable. Let's say that we are interested only in the fish that occur in lake "AL". We can use `filter()` to extract these observations.  
```{r}
filter(fish, lakeid == "AL")
```

Similarly, if we are only interested in fish with a length greater than or equal to 350 we can use `filter()` to extract these observations.  
```{r}
filter(fish, length >= 350)
```

+ `filter()` allows all of the expected operators; i.e. >, >=, <, <=, != (not equal), and == (equal).  

Using the `!` operator allows for the exclusion of specific observations.
```{r}
filter(fish, lakeid != "AL")
```

## Using `filter()` with multiple observations  
Filtering multiple values within the same variable requires the `%in%` [operator](https://www.tutorialspoint.com/r/r_operators.htm).    
```{r}
filter(fish, length %in% c(167, 175))
```

Alternatively, you can use `between` if you are looking for a range of specific values.  
```{r}
filter(fish, between(scalelength, 2.5, 2.55))
```

You can also extract observations "near" a certain value but you need to specify a tolerance.  
```{r}
filter(fish, near(radii_length_mm, 2, tol = 0.2))
```

## Practice
1. Filter the `fish` data to include the samples from lake "BO".
```{r}
filter(fish, lakeid=="BO")
```

2. Filter the data to include all lakes except "AR".
```{r}
filter(fish, lakeid != "AR")
```

3. Filter the fish data to include all fish with a scalelength within 0.25 of 8.
```{r}
filter(fish, near(scalelength, 8, tol=0.5))
```

4. Filter the fish data to include fish with a scalelength between 2 and 4.
```{r}
filter(fish, between(scalelength, 2, 4))
```

```{r}
filter(fish, scalelength %in% c(2, 4))
```
Lab5_1


## Review
In the warm-up, we practiced extracting observations of interest. For example, we can pull out all of the fish from a specific lake.  
```{r}
glimpse(fish)
```

Let's convert `lakeid` to a factor and have a look at which states are represented in the data.  
```{r}
fish$lakeid <- as.factor(fish$lakeid)
levels(fish$lakeid)
```

Now we can pull out any state of interest.  
```{r}

```

## Using `filter()` on multiple conditions
You can also use `filter()` to extract data based on multiple conditions. Below we extract only the fish that have lakeid "AL" and length >350.
```{r}
filter(fish, lakeid == "AL" & length > 350)
```

Notice that the `|` operator generates a different result.
```{r}
filter(fish, lakeid == "AL" | length > 350)
```

Rules:  
+ `filter(condition1, condition2)` will return rows where both conditions are met.  
+ `filter(condition1, !condition2)` will return all rows where condition one is true but condition 2 is not.  
+ `filter(condition1 | condition2)` will return rows where condition 1 or condition 2 is met.  
+ `filter(xor(condition1, condition2)` will return all rows where only one of the conditions is met, and not when both conditions are met.  

In this case, we filter out the fish with a length over 400 and a scale length over 11 or a radii length over 8.
```{r}
filter(fish, length > 400, (scalelength > 11 | radii_length_mm > 8))
```

## Load the data
For this lab, we will use the following two datasets:  

1. Gaeta J., G. Sass, S. Carpenter. 2012. Biocomplexity at North Temperate Lakes LTER: Coordinated Field Studies: Large Mouth Bass Growth 2006. Environmental Data Initiative.   [link](https://portal.edirepository.org/nis/mapbrowse?scope=knb-lter-ntl&identifier=267)  
```{r}
fish <- readr::read_csv("data/Gaeta_etal_CLC_data.csv")
```

2. S. K. Morgan Ernest. 2003. Life history characteristics of placental non-volant mammals. Ecology 84:3402.   [link](http://esapubs.org/archive/ecol/E084/093/)  
```{r}
mammals <- readr::read_csv("data/mammal_lifehistories_v2.csv")
```

Let's rename some of the `mammals` variables.  
```{r}
mammals <- rename(mammals, genus="Genus", wean_mass="wean mass", max_life= "max. life", litter_size="litter size", litters_per_year="litters/year")
```

## Pipes `%>%` 
In order to start combining `select()`, `filter()`, and other functions efficiently, we need to learn pipes. Pipes feed the output from one function into the input of another function. This helps us keep our code sequential and clean.  

In this example, we use a pipe to select only `lakeid` and `scalelength` then filter that output only for lakes "AL". Notice that we only need to call the data one time.  
```{r}
select(fish, lakeid, scalelength)
```

```{r}
filter(fish, lakeid == "AL")
```

```{r}
fish %>%
  select(lakeid, scalelength) %>%
  filter(lakeid == "AL")
```

Here we select family, genus, and species then filter for gestation greater than 15 months.
```{r}
mammals %>% 
  select(family, genus, species, gestation) %>% 
  filter(gestation>=15)
```

## Practice
1. We are interested in the fish from the lakes "AL" and "AR" with a radii length between 2 and 4. Extract this information from the `fish` data. Use pipes!  
```{r}

```

## `arrange()`
The `arrange()` command is a bit like a sort command in excel. Note that the default is ascending order.  
```{r}
fish %>% 
  select(lakeid, scalelength) %>% 
  arrange(scalelength)
```

To sort in decreasing order, wrap the variable name in `desc()`.
```{r}
fish %>% 
  select(lakeid, scalelength) %>% 
  arrange(desc(scalelength))
```

`arrange()` can be very helpful in combination with the other functions.
```{r}
fish %>% 
  select(lakeid, length, fish_id, scalelength) %>% 
  filter(lakeid=="AL") %>% 
  arrange(fish_id)
```

## Practice
1. We are interested in the radii length and scalelength of fish with the id `300`. Extract this information from the `fish` data. Please sort the data by radii length.
```{r}

```

## `mutate()`  
Mutate allows us to create a new column from existing columns in a data frame. We are doing a small introduction here and will add some additional functions later. Let's convert the length variable from cm to millimeters and create a new variable called length_mm.  
```{r}
fish %>% 
  mutate(length_mm = length*10) %>% 
  select(fish_id, length, length_mm)
```

## `mutate_all()`
This last function is super helpful when cleaning data. With "wild" data, there are often mixed entries (upper and lowercase), blank spaces, odd characters, etc. These all need to be dealt with before analysis.  

Here is an example that changes all entries to lowercase (if present).  
```{r}
mammals %>%
  mutate_all(tolower)
```

Using the across function we can specify individual columns.
```{r}
mammals %>% 
  mutate(across(c("order", "family"), tolower))
```

## `if_else()`
We will briefly introduce `if_else()` here because it allows us to use `mutate()` but not have the entire column affected in the same way. In a sense, this can function like find and replace in a spreadsheet program. With `ifelse()`, you first specify a logical statement, afterwards what needs to happen if the statement returns `TRUE`, and lastly what needs to happen if it's  `FALSE`.  

Have a look at the data from mammals below. Notice that the values for newborn include `-999.00`. This is sometimes used as a placeholder for NA (but, is a really bad idea). We can use `if_else()` to replace `-999.00` with `NA`.  
```{r}
mammals %>% 
  select(genus, species, newborn) %>% 
  arrange(newborn)
```

```{r}
mammals %>% 
  select(genus, species, newborn) %>%
  mutate(newborn_new = ifelse(newborn == -999.00, NA, newborn))%>% 
  arrange(newborn)
```

Lab6_1


## Pipes `%>%` 
Recall that we use pipes to connect the output of code to a subsequent function. This makes our code cleaner and more efficient. One way we can use pipes is to attach the `clean_names()` function from janitor to the `read_csv()` output.  
```{r}
fish <- readr::read_csv("data/Gaeta_etal_CLC_data.csv")
```

```{r}
mammals <- read_csv("data/mammal_lifehistories_v2.csv") %>% clean_names()
```

## `mutate()`  
Mutate allows us to create a new column from existing columns in a data frame. We are doing a small introduction here and will add some additional functions later. Let's convert the length variable from cm to millimeters and create a new variable called length_mm.  
```{r}
fish %>% 
  mutate(length_mm = length*10) %>% 
  select(fish_id, length, length_mm)
```

## Practice
1. Use `mutate()` to make a new column that is the half length of each fish: length_half = length/2. Select only fish_id, length, and length_half.
```{r}

```

## `mutate_all()`
This last function is super helpful when cleaning data. With "wild" data, there are often mixed entries (upper and lowercase), blank spaces, odd characters, etc. These all need to be dealt with before analysis.  

Here is an example that changes all entries to lowercase (if present).  
```{r}
mammals
```

```{r}
mammals %>%
  mutate_all(tolower)
```

Using the across function we can specify individual columns.
```{r}
mammals %>% 
  mutate(across(c("order", "family"), tolower))
```

## `if_else()`
We will briefly introduce `if_else()` here because it allows us to use `mutate()` but not have the entire column affected in the same way. In a sense, this can function like find and replace in a spreadsheet program. With `ifelse()`, you first specify a logical statement, afterwards what needs to happen if the statement returns `TRUE`, and lastly what needs to happen if it's  `FALSE`.  

Have a look at the data from mammals below. Notice that the values for newborn include `-999.00`. This is sometimes used as a placeholder for NA (but, is a really bad idea). We can use `if_else()` to replace `-999.00` with `NA`.  
```{r}
mammals %>% 
  select(genus, species, newborn) %>% 
  arrange(newborn)
```

```{r}
mammals %>% 
  select(genus, species, newborn) %>%
  mutate(newborn_new = ifelse(newborn == -999.00, NA, newborn))%>% 
  arrange(newborn)
```
## `tabyl`
The `janitor` package has many awesome functions that we will explore. Here is its version of `table` which not only produces counts but also percentages. Very handy! Let's use it to explore the proportion of good guys and bad guys in the `superhero_info` data.  
```{r}
#tabyl(superhero_info, alignment)
```


3. (2 points) Please load these data as a new object called `elephants`. Use the function(s) of your choice to get an idea of the structure of the data. Be sure to show the class of each variable.
```{r}
elephants <- readr::read_csv(file="data/ElephantsMF.csv")
```

```{r}
glimpse(elephants)
```

4. (2 points) Change the names of the variables to lower case and change the class of the variable `sex` to a factor.
```{r}
elephants <- janitor::clean_names(elephants)
```

```{r}
elephants$sex <- as.factor(elephants$sex)
```

5. (2 points) How many male and female elephants are represented in the data?
```{r}
elephants %>% 
  count(sex)
```

6. (2 points) What is the average age all elephants in the data?
```{r}
elephants %>% 
  summarize(mean_age=mean(age))
```

7. (2 points) How does the average age and height of elephants compare by sex?
```{r}
elephants %>% 
  group_by(sex) %>% 
  summarise(mean_age=mean(age),
            mean_height=mean(height))
```

8. (2 points) How does the average height of elephants compare by sex for individuals over 20 years old. Include the min and max height as well as the number of individuals in the sample as part of your analysis.  
```{r}
elephants %>% 
  filter(age>20) %>% 
  group_by(sex) %>% 
  summarise(min_height=min(height),
            max_height=max(height),
            mean_height=mean(height),
            n_elephants=n())
```

For the next series of questions, we will use data from a study on vertebrate community composition and impacts from defaunation in [Gabon, Africa](https://en.wikipedia.org/wiki/Gabon). One thing to notice is that the data include 24 separate transects. Each transect represents a path through different forest management areas.  

Reference: Koerner SE, Poulsen JR, Blanchard EJ, Okouyi J, Clark CJ. Vertebrate community composition and diversity declines along a defaunation gradient radiating from rural villages in Gabon. _Journal of Applied Ecology_. 2016. This paper, along with a description of the variables is included inside the midterm 1 folder.  

9. (2 points) Load `IvindoData_DryadVersion.csv` and use the function(s) of your choice to get an idea of the overall structure. Change the variables `HuntCat` and `LandUse` to factors.
```{r}
gabon <- readr::read_csv("data/IvindoData_DryadVersion.csv")
```

```{r}
gabon <- gabon %>% 
  mutate_if(is.character, factor)
```

10. (4 points) For the transects with high and moderate hunting intensity, how does the average diversity of birds and mammals compare?
```{r}
gabon %>% 
  group_by(HuntCat) %>% 
  summarise(mean_bird_diversity=mean(Diversity_BirdSpecies),
            mean_mammal_diversity=mean(Diversity_MammalSpecies),
            nsamples=n())
```

```{r}
gabon %>% 
  filter(HuntCat=="High") %>% 
  summarise(mean_bird_diversity=mean(Diversity_BirdSpecies),
            mean_mammal_diversity=mean(Diversity_MammalSpecies),
            nsamples=n())
```

```{r}
gabon %>% 
  filter(HuntCat=="Moderate") %>% 
  summarise(mean_bird_diversity=mean(Diversity_BirdSpecies),
            mean_mammal_diversity=mean(Diversity_MammalSpecies),
            nsamples=n())
```

```{r}
names(gabon)
```

11. (4 points) One of the conclusions in the study is that the relative abundance of animals drops off the closer you get to a village. Let's try to reconstruct this (without the statistics). How does the relative abundance (RA) of apes, birds, elephants, monkeys, rodents, and ungulates compare between sites that are less than 3km from a village to sites that are greater than 25km from a village? The variable `Distance` measures the distance of the transect from the nearest village. Hint: try using the `across` operator.  

Close
```{r}
gabon %>% 
  filter(Distance<3) %>% 
  summarise(across(contains("RA_"), mean))
```

Far
```{r}
gabon %>% 
  filter(Distance>25) %>% 
  summarise(across(contains("RA_"), mean))



Diplr functions:

filter — filters rows;
arrange — sorts a dataframe;
mutate — creates new columns;
sample_n —samples n rows from a dataframe;
sample_frac — samples a percentage of rows from a dataframe;
summarize — performs aggregate functions;
group_by — groups data by a specific key;














